"""
Markdown comment builder for PR analysis results
"""

from typing import List, Dict, Any
from app.models.schemas import PRAnalysis, SecretDetection, DependencyChange, TestSuggestion, ReviewChecklistItem
from app.logging import get_logger

logger = get_logger(__name__)


class CommentBuilder:
    """Builder for Markdown PR comments"""
    
    def __init__(self):
        self.template = """<!-- pr-auto-orchestrator: v1 -->
### ðŸ¤– PR Intelligence Summary

**High-Level Summary**  
{summary}

**Changelog**
{changelog_section}

### ðŸ” Risk & Security
Risk Score: **{risk_score} / 100**  
{risk_factors_section}

{secrets_section}

{dependencies_section}

### ðŸ§ª Suggested Tests
{tests_section}

### âœ… Review Checklist
{checklist_section}

---
_Generated by DevOps PR Auto-Orchestrator in {total_time_ms}ms_"""
    
    def build_comment(self, analysis: PRAnalysis) -> str:
        """
        Build complete Markdown comment from analysis results
        
        Args:
            analysis: Complete PR analysis results
            
        Returns:
            Formatted Markdown comment
        """
        return self.template.format(
            summary=analysis.summary or "No summary available",
            changelog_section=self._build_changelog_section(analysis.changelog),
            risk_score=analysis.risk_score,
            risk_factors_section=self._build_risk_factors_section(analysis.risk_factors),
            secrets_section=self._build_secrets_section(analysis.secrets_detected),
            dependencies_section=self._build_dependencies_section(analysis.dependency_changes),
            tests_section=self._build_tests_section(analysis.test_suggestions),
            checklist_section=self._build_checklist_section(analysis.review_checklist),
            total_time_ms=sum(analysis.agent_times_ms.values())
        )
    
    def _build_changelog_section(self, changelog: Dict[str, List[str]]) -> str:
        """Build changelog section"""
        if not changelog:
            return "- No specific changes categorized"
        
        sections = []
        
        for category, items in changelog.items():
            if items:
                section_name = category.title()
                section_items = '\n'.join(f"  - {item}" for item in items)
                sections.append(f"- **{section_name}:**\n{section_items}")
        
        return '\n'.join(sections) if sections else "- No specific changes categorized"
    
    def _build_risk_factors_section(self, risk_factors: List[str]) -> str:
        """Build risk factors section"""
        if not risk_factors:
            return "No specific risk factors identified."
        
        factors_text = '\n'.join(f"- {factor}" for factor in risk_factors)
        return f"**Risk Factors:**\n{factors_text}"
    
    def _build_secrets_section(self, secrets: List[SecretDetection]) -> str:
        """Build secrets detection section"""
        if not secrets:
            return "**Secrets Detected:** None âœ…"
        
        secrets_by_type = {}
        for secret in secrets:
            pattern_type = secret.pattern_type
            if pattern_type not in secrets_by_type:
                secrets_by_type[pattern_type] = []
            secrets_by_type[pattern_type].append(secret)
        
        sections = [f"**âš ï¸ Secrets Detected:** {len(secrets)} potential secrets found"]
        
        for pattern_type, detections in secrets_by_type.items():
            files = set(detection.filename for detection in detections)
            sections.append(f"- **{pattern_type}**: {len(detections)} occurrence(s) in {len(files)} file(s)")
            for filename in sorted(files):
                file_detections = [d for d in detections if d.filename == filename]
                lines = [str(d.line_number) for d in file_detections]
                sections.append(f"  - `{filename}` (lines: {', '.join(lines)})")
        
        sections.append("\n> âš ï¸ Please review and remove any exposed secrets before merging.")
        
        return '\n'.join(sections)
    
    def _build_dependencies_section(self, dependencies: List[DependencyChange]) -> str:
        """Build dependency changes section"""
        if not dependencies:
            return "**Dependency Changes:** None"
        
        sections = ["**Dependency Changes:**"]
        
        # Group by change type
        changes_by_type = {}
        for dep in dependencies:
            change_type = dep.change_type
            if change_type not in changes_by_type:
                changes_by_type[change_type] = []
            changes_by_type[change_type].append(dep)
        
        # Create table
        if dependencies:
            sections.append("\n| Package | From | To | Change | Risk Level |")
            sections.append("|---------|------|----|--------|------------|")
            
            for dep in dependencies:
                old_ver = dep.old_version or "-"
                new_ver = dep.new_version or "-"
                risk_emoji = self._get_risk_emoji(dep.risk_level)
                
                sections.append(
                    f"| {dep.package} | {old_ver} | {new_ver} | {dep.change_type} | {risk_emoji} {dep.risk_level} |"
                )
        
        return '\n'.join(sections)
    
    def _build_tests_section(self, test_suggestions: List[TestSuggestion]) -> str:
        """Build test suggestions section"""
        if not test_suggestions:
            return "No specific test suggestions generated."
        
        sections = []
        
        # Group by target file
        tests_by_file = {}
        for test in test_suggestions:
            filename = test.target_file
            if filename not in tests_by_file:
                tests_by_file[filename] = []
            tests_by_file[filename].append(test)
        
        for filename, tests in tests_by_file.items():
            sections.append(f"**`{filename}`:**")
            for test in tests:
                function_info = f" ({test.function_name})" if test.function_name else ""
                sections.append(f"- **{test.test_type.title()} Test{function_info}**: {test.description}")
                if test.rationale:
                    sections.append(f"  - *Rationale*: {test.rationale}")
                if test.sample_stub:
                    sections.append(f"  - *Example*: `{test.sample_stub}`")
            sections.append("")  # Empty line between files
        
        return '\n'.join(sections)
    
    def _build_checklist_section(self, checklist: List[ReviewChecklistItem]) -> str:
        """Build review checklist section"""
        if not checklist:
            return "- [ ] Standard code review (no specific items generated)"
        
        # Group by severity
        high_priority = [item for item in checklist if item.severity == 'high']
        medium_priority = [item for item in checklist if item.severity == 'medium']
        low_priority = [item for item in checklist if item.severity == 'low']
        
        sections = []
        
        if high_priority:
            sections.append("**High Priority:**")
            for item in high_priority:
                ref = f" (`{item.line_reference}`)" if item.line_reference else ""
                sections.append(f"- [ ] **{item.category}**: {item.text}{ref}")
            sections.append("")
        
        if medium_priority:
            sections.append("**Medium Priority:**")
            for item in medium_priority:
                ref = f" (`{item.line_reference}`)" if item.line_reference else ""
                sections.append(f"- [ ] {item.category}: {item.text}{ref}")
            sections.append("")
        
        if low_priority:
            sections.append("**Low Priority:**")
            for item in low_priority:
                ref = f" (`{item.line_reference}`)" if item.line_reference else ""
                sections.append(f"- [ ] {item.text}{ref}")
        
        return '\n'.join(sections)
    
    def _get_risk_emoji(self, risk_level: str) -> str:
        """Get emoji for risk level"""
        risk_emojis = {
            'high': 'ðŸ”´',
            'medium': 'ðŸŸ¡',
            'low': 'ðŸŸ¢'
        }
        return risk_emojis.get(risk_level, 'âšª')
    
    def build_simple_comment(self, summary: str, risk_score: int) -> str:
        """Build a simple comment when full analysis fails"""
        return f"""<!-- pr-auto-orchestrator: v1 -->
### ðŸ¤– PR Intelligence Summary

**Summary:** {summary}

**Risk Score:** {risk_score} / 100

---
_Generated by DevOps PR Auto-Orchestrator (Simple Analysis)_"""